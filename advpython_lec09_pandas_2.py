# -*- coding: utf-8 -*-
"""advpython_lec09_pandas_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bT7vL7egY9swrhD17OiDDfk8__aB1lTT

### 10주차 강의 Pandas 2
"""

import numpy as np
import pandas as pd

# DataFrame

# 데이터프레임 객체 생성 방법:
# 1. 딕셔너리에서 데이터프레임 객체 생성

# a. 기본 형태: 값으로 리스트 배열 사용
data1 = {'이름': ['Wonyoung', 'Hayoung', 'Soyeon'],
        '나이': [22, 29, 26],
        '그룹': ['IVE', 'fromis_9', 'GIdle']}

df1 = pd.DataFrame(data1)
print(f'값으로 리스트 배열 사용: \n{df1}'), print('='*50)

# b. 기본 형태: 값으로 NumPy 배열 사용
data2 = {'이름': np.array(['Wonyoung', 'Hayoung', 'Soyeon']),
        '나이': np.array([22, 29, 26]),
        '그룹': np.array(['IVE', 'fromis_9', 'GIdle'])}

df2 = pd.DataFrame(data2)
print(f'값으로 NumPy 배열 사용: \n{df2}'), print('='*50)

# c. 인덱스 명시하기
df3 = pd.DataFrame(data2, index = ['top1', 'top2', 'top3'])
print(f'인덱스 명시하기: \n{df3}')

# DataFrame

# 데이터프레임 객체 생성 방법:
# 1. 딕셔너리에서 데이터프레임 객체 생성

# d. 값으로 Series 객체의 딕셔너리 사용
# 딕셔너리에서 인덱스로 생성한 데이터프레임은 여러 시리즈 인덱스들의 합집합 (union)임
data3 = {'one': pd.Series([1, 2, 3], index=['a', 'b', 'c']),
        'two': pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}

df4 = pd.DataFrame(data3)
print(f'값으로 Series 객체 사용: \n{df4}'), print('-'*50)

print(df4.info()), print('-'*50)
print(df4.dtypes), print('='*50)

# 인덱스와 열 속성을 이용해 각 행과 열 라벨에 접근할 수 있음
print(df4.index), print('-'*50)
print(df4.columns), print('='*50)

# 인덱스와 열 라벨 순서를 변경할 수 있음
df5 = pd.DataFrame(data3, index = ['d', 'b', 'a'])
print(df5), print('='*50)

df6 = pd.DataFrame(data3, index = ['d', 'b', 'a'], columns = ['two', 'three'])
print(df6)

# DataFrame

# df.dtypes vs. df.dtype

# df.dtypes
data = {'col1': [1, 2, 3],
        'col2': [1.1, 2.2, 3.3],
        'col3': ['a', 'b', 'c'],
        'col4': [True, False, True]}

df = pd.DataFrame(data)
print(df), print('-'*30)
print(df.dtypes), print('-'*30)
print(f'df.dtypes 자료형: \n{type(df.dtypes)}'),print('='*30)

# df.dtype
# DataFrame 객체에서 하나의 열을 선택한 후 dtype 확인
print(df['col1'].dtype)

# DataFrame

# 데이터프레임 객체 생성 방법:
# 2. 구조화된 배열 또는 레코드 배열에서 데이터프레임 객체 생성

# 구조화된 배열의 데이터 타입 정의 및 구조화된 배열 생성
dtype = np.dtype([('성', 'U10'), ('나이', 'i4'), ('키', 'f8')])
data = np.array([('Jang', 22, 173.), ('Song', 29, 163.), ('Jeon', 28, 156.5)],
                dtype=dtype)

print(f"구조화된 NumPy 배열: \n{data}"), print('-'*50)
print(data.dtype), print('='*50)

# 구조화된 배열로부터 DataFrame 생성
df = pd.DataFrame(data)
print(f"DataFrame: \n{df}"), print('='*50)

# 인덱스 명시하기 (index 파라미터)
df2 = pd.DataFrame(data, index = ['first', 'second', 'third'])
print(f"DataFrame with index: \n{df2}"), print('='*50)

# 열 순서 지정
df3 = pd.DataFrame(data, columns = ['나이', '키', '성'])
print(f"DataFrame with changed columns: \n{df3}")

# DataFrame

# 데이터프레임 객체 생성 방법:
# 3. 딕셔너리를 요소로 갖는 리스트로 데이터프레임 객체 생성

data = [{'그룹': 'AESPA', '멤버수': 4, '데뷔연도': '2020'},
        {'그룹': 'KiiKii', '멤버수': 5, '데뷔연도': '2025'},
        {'그룹': 'IVE', '멤버수': 6, '데뷔연도': '2021'}]

df = pd.DataFrame(data)
print(df), print('='*50)

# 누락된 키 처리
data2 = [{'그룹': 'AESPA', '멤버수': 4},            # 데뷔연도 누락됨
         {'그룹': 'KiiKii', '데뷔연도': '2025'},    # 멤버수 누락됨
         {'그룹': 'IVE', '멤버수': 6, '데뷔연도': '2021'}]

df2 = pd.DataFrame(data2)
print(df2)

# DataFrame

# 데이터프레임 객체 생성 방법:
# 4. 튜플을 키로 갖는 딕셔너리에서 데이터프레임 객체 생성

# 튜플을 DataFrame의 열 이름으로 사용하는 경우
data = {('a'): [1, 2, 3],
        ('b'): [4, 5, 6],
        ('c'): [7, 8, 9]}
df = pd.DataFrame(data)
print(df)

# DataFrame

# 데이터프레임 객체 생성 방법:
# 4. 튜플을 키로 갖는 딕셔너리에서 데이터프레임 객체 생성

# MultiIndex를 사용하는 경우
# 튜플을 열 이름으로 사용하는 경우
data_columns = {('IVE', 'Liz'): ['Jeju', 22],   # 각 열이 동일한 데이터 타입이 아님
                ('IVE', 'Rei'): ['Nagoya', 23],
                ('AESPA', 'Winter'): ['Busan', 26]}

df_columns = pd.DataFrame(data_columns)
print(f"MultiIndex DataFrame: \n{df_columns}"), print('-'*50)
print(df_columns.dtypes), print('='*50)

###### 참고) 위에서.. ###########################################
# 하나의 열에 여러 타입의 데이터가 섞여 있음
# Pandas는 그 모든 데이터를 담을 수 있는 가장 일반적인 타입
# (주로 object)으로 자동 변환(업캐스팅)하여 DataFrame을 생성
# ojbect는 모든 파이썬 클래스의 최상위 부모 클래스임
#################################################################


# 튜플을 다중 인덱스의 레벨로 사용하는 경우 (Series의 딕셔너리 형태)
data_index = {'Birthplace': pd.Series(['Jeju', 'Nagoya'],
                                      index=[('IVE', 'Liz'), ('IVE', 'Rei')]),
              'Age': pd.Series([22, 26], index=[('IVE', 'Liz'), ('AESPA', 'Winter')])}
df_index = pd.DataFrame(data_index)
print("튜플을 다중 인덱스의 레벨로 사용한 DataFrame:")
print(df_index), print('-'*50)
print(df_index.dtypes)

# DataFrame

# 데이터프레임 객체 생성 방법:
# 4. 튜플을 키로 갖는 딕셔너리에서 데이터프레임 객체 생성

# MultiIndex를 사용하는 경우 (교재의 예시)
data2 = {('a', 'x'): [1, 2, 3],
        ('a', 'y'): [4, 5, 6],
        ('b', 'z'): [7, 8, 9]}

df2 = pd.DataFrame(data2)
print(df2), print('='*50)

df3 = pd.DataFrame({('a', 'b'): {('A', 'B'): 1, ('A', 'C'): 2},
                    ('a', 'a'): {('A', 'C'): 3, ('A', 'B'): 4},
                    ('a', 'c'): {('A', 'B'): 5, ('A', 'C'): 6},
                    ('b', 'a'): {('A', 'C'): 7, ('A', 'B'): 8},
                    ('b', 'b'): {('A', 'D'): 9, ('A', 'B'): 10}})

print(df3), print('-'*50)
print(df3.index), print('-'*50)
print(df3.columns)

# DataFrame

# 데이터프레임 객체 생성 방법:
# 5-1. 데이터프레임 생성자로부터 객체 생성 (DataFrame.from_dict 생성자)
data1 = {'이름': ['Wonyoung', 'Hayoung', 'Soyeon'],
        '나이': [22, 29, 26],
        '그룹': ['IVE', 'fromis_9', 'GIdle']}

df0 = pd.DataFrame.from_dict(data1)
df1 = pd.DataFrame.from_dict(data1, orient='columns')   # orinet='columns' 기본값
print(df0), print('-'*50)
print(df1), print('='*50)

# orient='index': 딕셔너리의 키를 행 인덱스(라벨)로, 값을 행 데이터로 해석
df2 = pd.DataFrame.from_dict(data1, orient='index')
print(df2), print('='*50)

# orient='index'에서 columns에는 원하는 열 이름을 리스트로 지정
df3 = pd.DataFrame.from_dict(data1, orient='index', columns=['one','two','three'])
print(df3)

# DataFrame

# 데이터프레임 객체 생성 방법:
# 5-2. 데이터프레임 생성자로부터 객체 생성 (DataFrame.from_records 생성자)
dtype = np.dtype([('성', 'U10'), ('나이', 'i4'), ('키', 'f8')])
data4 = np.array([('Jang', 22, 173.), ('Song', 29, 163.), ('Jeon', 28, 156.5)],
                 dtype=dtype)
print(data4), print('='*30)

df4 = pd.DataFrame.from_records(data4)
print(df4), print('='*30)

df5 = pd.DataFrame.from_records(data4, index = ['top1','top2','top3'])
print(df5), print('='*30)

df6 = pd.DataFrame.from_records(data4, index = '성')
print(df6)

# 행과 열의 기본 처리

# 열 선택
d = {'one': pd.Series([1., 2., 3.], index = ['a', 'b', 'c']),
     'two': pd.Series([1., 2., 3., 4.], index = ['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)
print(df), print('='*30)

# 단일 열 선택
print(df['one']), print('='*30)

# 여러 열 선택 (대괄호 주의): 열 이름들을 리스트 형태로 묶음
print(df[['one','two']]), print('='*30)
#print(df['one','two']), print('='*30)

# 행과 열의 기본 처리

# 행 선택

# DataFrame.loc[] 속성 vs. DataFrame.iloc[] 속성
data = {'A': [10, 20, 30],
        'B': [100, 200, 300]}
index=['x', 'y', 'z']

df = pd.DataFrame(data, index = index)

# DataFrame.loc[] 속성
print(df), print('-'*30)
print(df.loc['x']), print('-'*30)       # index 라벨이 'x'인 행 반환
print(df.loc['x':'y']), print('-'*30)   # 'x'부터 'y'까지 ('y'까지 포함)
print(df.loc['x', 'B']), print('='*30)  # 'x'행, 'B'열 값 선택 -> 100

# DataFrame.iloc[] 속성
print(df.iloc[0]), print('-'*30)        # 0번째 행 반환
print(df.iloc[0:2]), print('-'*30)      # 0~1번째 행 (2번째는 제외)
print(df.iloc[0, 1])                    # 0행 1열 -> 100

# 행과 열의 기본 처리

# 행 선택

# DataFrame.loc[] 속성 vs. DataFrame.iloc[] 속성
df = pd.DataFrame({'name': ['A', 'B', 'C', 'D'],
                    'age': [23, 35, 19, 42]})
print(df), print('='*30)

# DataFrame.loc[] 속성 : 라벨 기반이지만, 조건이 들어가면
#               Boolean Series를 받아 해당하는 행만 선택
print(df.loc[df['age'] >= 30])  # age가 30 이상인 행만 선택
print('='*30)

# DataFrame.iloc[] 속성 : Boolean 배열을 사용할 수 있지만,
#                        정수 위치 기준의 Boolean 배열이어야 함
mask = [False, True, False, True] # df에서 1번과 3번 행만 True로 설정
print(df.iloc[mask])

# 행과 열의 기본 처리

# 행 또는 열 추가
# 열 추가
d = {'one': pd.Series([1., 2., 3.], index = ['a', 'b', 'c']),
     'two': pd.Series([1., 2., 3., 4.], index = ['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)
print(df), print('='*30)

df['three'] = df['one'] * df['two']
print(df), print('='*30)

# 열 추가
df['flag'] = df['one'] > 2
print(df), print('='*40)

# 데이터프레임과 다른 인덱스를 가진 시리즈를 삽입할 때는 데이터프레임의 인덱스에 맞춤
df['truncated_one'] = df['one'][:2]   # df['one'][:2]는 시리즈 객체 타입임
print(df)

# 데이터프레임에 스칼라 값을 동적할당하면 브로드캐스팅으로 열을 채움
df['ha'] = 'hiho'
print(df)

# 행과 열의 기본 처리

# DataFrame.insert() 메소드: 특정 위치에 열을 삽입
print(df), print('='*50)

# 1: 1번째 열
# 'hi': 삽입할 열 라벨
# df['one']: 삽입할 값(시리즈 형)
df.insert(1, 'hi', df['one'])
print(df)

# 행과 열의 기본 처리

# 행 또는 열 추가
# 행 추가
d = {'one': pd.Series([1., 2., 3.], index=['a', 'b', 'c']),
     'two': pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)

df['three'] = df['one'] * df['two']
print(f"원본 DataFrame: \n{df}"), print('='*30)

# 새로운 행 'e' 추가 (모든 기존 열에 값 지정)
df.loc['e'] = [4.0, 5.0, 6.0]
print(f"e 행 추가: \n{df}"), print('='*30)

# 새로운 행 'f' 추가 (기존 열 중 일부에만 값 지정, 나머지는 NaN)
df.loc['f'] = {'one': 5.0, 'two': 6.0}
print(f"f 행 추가: \n{df}"), print('='*30)

# iloc[]는 에러 발생
df.iloc[6] = {'one': 5.0, 'two': 6.0}
print(f"g 행 추가: \n{df}"), print('='*30)

# 행과 열의 기본 처리

# del 키워드
del df['two']
print(df), print('='*50)

# pandas.DataFrame.pop 메소드: 열을 추출하고 그 요소를 시리즈로 반환
three = df.pop('three')

print(three), print('-'*50)
print(three.values), print('-'*50)
print(type(three)), print('='*50)

# 행과 열의 기본 처리

# pandas.Series.drop 함수:
# 인덱스 라벨을 기준으로 시리즈의 요소를 제거하며, 요소를 제거한 시리즈 객체를 결과로 반환
s1 = pd.Series(data = np.arange(3), index = ['A', 'B', 'C'])
print(s1), print('-'*30)

s2 = s1.drop(['B', 'C'])
print(s2), print('='*30)

# pandas.DataFrame.drop:
# 라벨 이름과 축을 입력하거나 직접 인덱스나 열 이름을 입력해 행이나 열을 제거
df1 = pd.DataFrame(np.arange(12).reshape(3, 4), columns = ['A', 'B', 'C', 'D'])
print(df1), print('-'*30)

df2 = df1.drop(['B', 'C'], axis = 1)  # 라벨 이름과 축으로 열 제거
print(df2), print('='*30)

df3 = df1.drop([0, 1])  # 인덱스로 행 제거 (axis=0이 기본값)
print(df3)

# 행과 열의 기본 처리

# 데이터 정렬 및 산술 연산
df = pd.DataFrame(np.random.randn(5, 4), columns = ['A', 'B', 'C', 'D'])

df2 = pd.DataFrame(np.random.randn(3, 3), columns = ['A', 'B', 'C'])

print(df), print('='*50)
print(df2), print('='*50)

# 데이터프레임 객체 간 연산을 실행하면, 행과 열 기준으로 자동 정렬됨
print(df + df2), print('='*50)


# 데이트프레임과 시리즈 간 연산을 실행하면, 데이터프레임 열에 시리즈 인덱스를 정렬
print(df - df.iloc[0]) # 행 방향으로 브로드캐스팅하는 것과 같음


# 데이트프레임과 스칼라 간 연산
print(df*10 + 2)

# 행과 열의 기본 처리

# 데이터 정렬 및 산술 연산 (불리언 연산자)
df1 = pd.DataFrame({'a': [1, 0, 1], 'b': [0, 1, 1]}, dtype = bool)
df2 = pd.DataFrame({'a': [0, 1, 1], 'b': [1, 1, 0]}, dtype = bool)

print(df1), print('='*50)
print(df2), print('='*50)

print(df1 & df2), print('='*50)
print(df1 | df2), print('='*50)
print(df1 ^ df2), print('='*50)
print(-df1), print('='*50)
print(~df1)

# 행과 열의 기본 처리

# 데이터 정렬 및 산술 연산 (전치)
df = pd.DataFrame(np.arange(12).reshape(3,4), columns = ['A', 'B', 'C', 'D'])

print(df), print('='*50)
print(df.T), print('='*50)

print(df[:2]), print('='*50)
print(df[:2].T)

# 행과 열의 기본 처리

# 데이터 정렬 및 산술 연산 (넘파이 함수들과 데이터프레임 연동)

df3 = pd.DataFrame(np.arange(12).reshape(3,4), columns = ['A', 'B', 'C', 'D'])
print(df3), print('='*50)

print(np.exp(df3)), print('='*50)

np3 = np.asarray(df3)
print(np3)

# 인덱스 관련 객체

# 인덱스 객체
# Index 생성자를 사용하여 정수 리스트를 기반으로 ind라는 Index 객체를 생성
ind = pd.Index([1, 3, 5, 7, 9, 11])

print(ind), print('='*50)       # 생성된 Index 객체 출력
print(ind[1]), print('='*50)    # Index 객체의 특정 요소 접근 (NumPy 배열과 유사하게 인덱싱)
print(ind[::2]), print('='*50)  # Index 객체 슬라이싱 (NumPy 배열과 동일한 슬라이싱 방식)
print(ind.size, ind.shape, ind.ndim, ind.dtype) # Index 객체의 속성 확인

# 인덱스 관련 객체

# 참고: Index는 중복된 값을 가질 수 있음
s = pd.Series([10, 20, 30, 40, 50], index=[1, 1, 3, 5, 5])
print(s)
print(s[1])  # 인덱스 1을 가진 모든 행 반환

# 인덱스 관련 객체

# pandas.Index 클래스
indA = pd.Index([1, 3, 5])
print(indA), print('='*50)

indB = pd.Index(list('abc'))
print(indB), print('='*50)

indC = indA.append(indB)
print(indC), print('='*50)

indD = indA.difference(indB)
print(indD)

# 인덱스 관련 객체

# pandas.RangeIndex 클래스
df = pd.DataFrame(np.arange(12).reshape(2,6), columns = list('ABCDEF'))

print(df), print('='*50)

# df.index는 명시적인 인덱스가 제공되지 않았기 때문에
# Pandas가 자동으로 생성한 RangeIndex 객체를 보여줌
print(df.index)

# 인덱스 관련 객체

# pandas.CategoricalIndex 클래스
s1 = pd.Series(['ha', 'hi']*1000)

print(s1), print('='*50)
# 각 문자열 'ha'와 'hi'는 여러 번 반복되어 저장되므로 메모리 사용량이 큼
print(s1.nbytes), print('='*50)

s2 = s1.astype('category')
print(s2), print('='*50)
# s2의 각 요소는 'ha','hi' 대신 해당 범주를 가리키는 짧은 정수 코드(0 또는 1)를 저장
print(s2.nbytes)

# 인덱스 관련 객체

# pandas.Categorical 클래스
s1 = pd.Categorical([1, 2, 3, 1, 2, 3])

print(s1), print('='*50)
print(type(s1), s1.dtype)

s2 = pd.Categorical(['a', 'b', 'c', 'a', 'b', 'c'])

print(s2), print('='*50)
print(type(s2), s2.dtype)

# ordered=True: 범주 순서에 따라 정렬되며 최소값과 최대값을 가질 수 있음
s3 = pd.Categorical(['a','b','c','a','b','c'],
                    ordered = True)

print(s3), print('='*50)
print(s3.min(), s3.max())

s4 = pd.Categorical(['a','b','c','a','b','c'],
                    ordered = True, categories = ['c','b','a'])

print(s4), print('='*50)
print(s4.min(), s4.max())

# 인덱스 관련 객체

# 범주를 가지는 시리즈나 데이터프레임의 열에서 범주형 데이터를 생성하는 방법
# 1. 시리즈를 구성할 때 dtype = 'category'를 명시하는 방법
s1 = pd.Series(['a','b','c','a'], dtype='category')
print(s1), print('='*50)


# 2. 데이터프레임 생성자에 dtype = 'category'를 명시하는 방법
df2 = pd.DataFrame({'A': list('abca'), 'B': list('bccd')}, dtype='category')
print(df2.dtypes), print('-'*50)
print(df2), print('-'*50)
print(df2['A']), print('-'*50)
print(df2['B']), print('='*50)


# 3. 시리즈나 데이터프레임의 열을 category dtype으로 변환하는 방법
df = pd.DataFrame({'A': ['a','b','c','a']})

print(df), print('-'*50)
df['B'] = df['A'].astype('category')
print(df.dtypes), print('-'*50)
print(df), print('='*50)


# 4. DataFrame.astype()을 사용하여 데이터프레임의 모든 열을 한꺼번에 범주형으로 변환하는 방법
df3 = pd.DataFrame({'A': list('abca'), 'B': list('bccd')})
df_cat = df3.astype('category')

print(df_cat.dtypes), print('-'*50)
print(df_cat)

# 인덱스 관련 객체

# MultiIndex 생성 방법 1: MultiIndex.from_arrays(arrays)
# 각 인덱스 레벨에 해당하는 배열 (리스트, NumPy 배열, Series)의 리스트를 입력으로 받음

arrays = [['IVE', 'IVE', 'AESPA', 'AESPA'],
          ['Wonyoung', 'Liz', 'Winter', 'Karina']]

multi_index_arrays = pd.MultiIndex.from_arrays(arrays, names=['그룹', '이름'])
print(multi_index_arrays)

# 인덱스 관련 객체

# MultiIndex 생성 방법 2: MultiIndex.from_product(iterables)
# 각 인덱스 레벨에 사용할 반복 가능한 객체 (리스트, 튜플 등)의 리스트를 입력으로 받음

groups = ['IVE', 'AESPA']
names = ['Wonyoung', 'Liz', 'Winter', 'Karina']
multi_index_product = pd.MultiIndex.from_product([groups, names], names=['그룹', '이름'])
print(multi_index_product)

# 인덱스 관련 객체

# MultiIndex 생성 방법 3: MultiIndex.from_tuples(tuples)
# MultiIndex를 구성할 튜플의 리스트를 직접 입력으로 받음

tuples = [('IVE', 'Wonyoung'), ('IVE', 'Liz'), ('AESPA', 'Winter'), ('AESPA', 'Karina')]
multi_index_tuples = pd.MultiIndex.from_tuples(tuples, names=['그룹', '이름'])
print(multi_index_tuples)

# 인덱스 관련 객체

# pandas.MultiIndex 클래스
arr = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]

mi_arr = pd.MultiIndex.from_arrays(arr, names=('number', 'color'))
print(mi_arr), print('='*50)

# 인덱스 생성자로 튜플의 리스트를 전달해 멀티인덱스를 반환
arr2 = [['ha','ha','hi','hi','ho','ho'], ['one','two','one','two','one','two']]

tuples = list(zip(*arr2))
print(tuples), print('-'*50)

mi_tuples = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])
print(mi_tuples)

# 인덱스 관련 객체

# pandas.MultiIndex 클래스
# 시리즈나 데이터프레임에 배열의 리스트를 직접 전달하면 멀티인덱스를 자동 생성할 수 있음
arr = [np.array(['ha','ha','hi','hi','ho','ho']),
       np.array(['one','two','one','two','one','two'])]

ser = pd.Series(np.random.randn(6), index=arr)
print(ser), print('='*50)

df = pd.DataFrame(np.random.randn(6, 4), index=arr)
print(df), print('-'*50)
print(df.index), print('='*50)

# 튜플을 축의 행 라벨로 사용할 수도 있음
arr2 = [['ha','ha','hi','hi','ho','ho'], ['one','two','one','two','one','two']]
tuples = list(zip(*arr2))
print(tuples), print('-'*50)

ser2 = pd.Series(np.random.randn(6), index=tuples)
print(ser2)

"""### 2. 판다스의 주요 기능"""

# head()와 tail() 메소드의 적용

s1 = pd.Series(np.random.randn(1000))

print(s1.head()), print('-'*30)
print(s1.tail()), print('='*30)
'''
# 모든 행을 출력하도록 설정
pd.set_option('display.max_rows', None)
print(s1)

# 설정을 다시 기본값으로 되돌리고 싶다면..
# 최대 60개의 행까지만 화면에 표시
# 만약 데이터가 60행을 초과하면, 처음 몇 행과 마지막 몇 행만 보여주고
# 중간 부분은 생략 부호(...)로 표시
pd.set_option('display.max_rows', 60)
print(s1)
'''

ind = pd.date_range('1/1/2021', periods = 5)
df = pd.DataFrame(np.random.randn(5,3), index=ind, columns=['A','B','C'])

print(df.shape), print('-'*40)
print(df), print('='*40)
print(df[:2])

# 판다스 객체 이진 연산

df2 = pd.DataFrame({'angles':[0, 3, 4], 'degrees':[360, 180, 360]},
                   index = ['circle', 'triangle', 'rectangle'])
print(df2), print('='*50)

# scalar 1을 더함
print(df2 + 1), print('='*50)
print(df2 - [1, 2]), print('='*50)
print(df2.sub([1, 2], axis='columns'))

# 판다스 객체 이진 연산

df = pd.DataFrame({'one': pd.Series(np.random.randn(2), index=['a','b']),
                   'two': pd.Series(np.random.randn(3), index=['a','b','c']),
                   'three': pd.Series(np.random.randn(2), index=['b','c'])})

print(df), print('-'*30)
print(df.iloc[1]), print('-'*30)
print(df['two']), print('='*30)

row = df.iloc[1]
col = df['two']

# 축의 값을 다르게 하여 sub()메소드 적용
# 'one' 열: df['one'] - row['one'], 'two' 열: df['two'] - row['two']
print(df.sub(row, axis='columns')), print('-'*30) # axis=1과 같음
# 'a' 행: df.loc['a'] - col['a'], 'b' 행: df.loc['b'] - col['b']
print(df.sub(col, axis='index'))    # axis=0과 같음

# 판다스 객체 이진 연산

# 손실값 대체
d = {'one': [1., 2., np.nan], 'two': [3., 2., 1.], 'three': [np.nan, 1., 1.]}
df = pd.DataFrame(d, index = list('abc'))
print(df), print('='*50)

d1 = {'one': pd.Series([1., 2.], index = ['a','b']),
      'two': pd.Series([1., 1., 1.], index = ['a','b','c']),
      'three': pd.Series([2., 2., 2.], index = ['a','b','c'])}
df1 = pd.DataFrame(d1)
print(df1), print('='*50)

# 위의 df와 df1을 더할 때 두 데이터프레임에 손실 값이 있으면 손실 값을
# 0으로 바꾸어 연산 가능.
# 또한 fillna()를 사용하여 손실 값을 다른 값으로 변경 가능
print(df + df1), print('='*50)
print(df.add(df1, fill_value=0))

# 요약과 통계 연산

d = {'one': [1., 2., np.nan], 'two': [3., 2., 1.], 'three': [np.nan, 1., 1.]}
df = pd.DataFrame(d, index = list('abc'))
print(df), print('='*20)

print(df.mean(axis=0)), print('-'*20)
print(df.mean(1)), print('='*20)

# skipna 옵션: 손실 데이터를 배제할지 결정하는 옵션. 기본값은 True
print(df.sum(0, skipna=False)), print('-'*20)
# print(df.sum(axis=0, skipna=False)), print('-'*20) 위와 같음
print(df.sum(1, skipna=True))

# 요약과 통계 연산

# mean(), std(), sum()과 같은 넘파이 함수들은 시리즈 입력값에 있는 손실 값을 기본으로 제외
print(df), print('-'*20)
print(np.mean(df['one']))

# 요약과 통계 연산
print(df), print('='*20)

# std()의 인수 ddof: 데이터프레임에서의 ddof 기본값=1, 넘파이에서의 ddof 기본값=0
print(df.std()), print('-'*20)
print(df.std(axis=1)), print('-'*20)        # 데이터프레임에서의 기본값 ddof=1
print(np.std(df, axis=1)), print('-'*20)    # 넘파이에서의 기본값 ddof=0
print(np.std(df, ddof=1, axis=1)), print('-'*20)
print(df[['one', 'two', 'three']].std())

# 요약과 통계 연산

# 누적 합을 계산하는 cumsum() 메소드는 아래와 같이 적용
print(df), print('-'*20)
print(df.cumsum())

# 요약과 통계 연산

# Series.nunique()
s1 = pd.Series(np.random.randn(500))
s1[20:500] = np.nan
s1[10:20] = 5
print(s1.nunique())

# 모든 행을 출력하도록 설정
pd.set_option('display.max_rows', None)
print(s1)

# 설정을 다시 기본값으로 되돌리고 싶다면
# pd.set_option('display.max_rows', 60)

# 요약과 통계 연산

# describe()
s2 = pd.Series(np.random.randn(1000))
s2[::2] = np.nan
print(s2.describe()), print('-'*30)

df = pd.DataFrame(np.random.randn(1000,4), columns=['a','b','c','d'])
df.iloc[::2] = np.nan
print(df.describe()), print('-'*30)

# 출력에 포함할 특정 백분위수를 선택할 수 있음
print(s2.describe(percentiles=[0.05, 0.25, 0.75, 0.95]))

# 요약과 통계 연산

# describe()
# 수치가 아닌 객체에 describe() 메소드를 적용하면, 유일값 수와 가장 빈번히 발생하는 값 요약
s3 = pd.Series(['a','a','b','c','c',np.nan,'c','d'])
print(s3.describe()), print('-'*30)

# 범주형과 수치가 혼합된 타입의 데이터프레임 객체에 describe() 메소드를 적용하면 수치로 이루어진 열만 반환
df = pd.DataFrame({'a': ['Yes','Yes','No','No'], 'b': range(4)})
print(df.describe()), print('-'*30)

# describe()에 include와 exclude (적용하지 않을 열 전달) 인수 적용 가능
print(df.describe(include=['object'])), print('-'*30)
print(df.describe(include=['number'])), print('-'*30)
print(df.describe(include='all'))

# 요약과 통계 연산

# idxmax()와 idxmin() 메소드
s1 = pd.Series(np.random.randn(5))
print(s1), print('-'*20)

print(s1.idxmin(), s1.idxmax())

df = pd.DataFrame(np.random.randn(4,3), columns=['A', 'B', 'C'])
print(df), print('-'*30)
print(df.idxmin(axis=0)), print('-'*30)
print(df.idxmin()), print('-'*30)
print(df.idxmax(axis=1)), print('='*30)

# 최소값과 최대값에 일치하는 행이나 열이 다수라면 첫 번째로 일치하는 인덱스 반환
df1 = pd.DataFrame([2, 1, 1, 3, np.nan], columns=['A'], index=list('edcba'))
print(df1), print('-'*30)

print(df1['A'].idxmin())

# 요약과 통계 연산

# value_counts() 메소드
data = np.random.randint(0, 7, size=30)
print(data), print('-'*60)

s1 = pd.Series(data)
print(s1.value_counts()), print('-'*30)

print(pd.value_counts(data))

# 요약과 통계 연산

# cut() 함수
print(pd.cut(np.array([1, 7, 5, 4, 6, 3]), bins=3)), print('='*80)

# 인수 retbins=True는 구간 값을 반환
print(pd.cut(np.array([1, 7, 5, 4, 6, 3]), 3, retbins=True)), print('='*80)

# 구간에 특정 라벨 ('bad', 'medium', 'good')을 할당하여 labels 범주를 반환하는 예
print(pd.cut(np.array([1, 7, 5, 4, 6, 3]), 3, labels=['bad','medium','good'])), print('='*80)

# labels=False를 입력하면 범주형 시리즈나 정수 배열을 반환
print(pd.cut([0, 1, 1, 2], bins=4)), print('='*80)
print(pd.cut([0, 1, 1, 2], bins=4, labels=False)), print('='*80)

# cut()함수에 시리즈를 입력하면 categorical dtype인 시리즈를 반환
s1 = pd.Series(np.array([2,4,6,8,10]), index=['a','b','c','d','e'])
print(pd.cut(s1, bins=3))

# 요약과 통계 연산

# qcut() 함수
print(pd.qcut(range(5),4)), print('-'*70)

print(pd.qcut(range(5), 3, labels=['good','medium','bad'])), print('-'*70)

print(pd.qcut(range(5), 4, labels=False))

# 요약과 통계 연산

# cut()과 qcut() 함수 차이
random_sample = np.random.randn(25)
print(pd.cut(random_sample, 5).value_counts())

print(pd.qcut(random_sample, 5).value_counts())