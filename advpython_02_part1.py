# -*- coding: utf-8 -*-
"""advPython_02_part1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IL2aWMVkz5KYLBlwvJ8JueXviR3jt3iA

### 파이썬 코딩 도장: https://dojang.io/course/view.php?id=7
### 점프 투 파이썬: https://wikidocs.net/book/1
"""

print("Hello python")

# 세미콜론: 한 줄에 여러 구문을 사용할 때 세미콜론으로 구분
print('hello'); print('1')

print(divmod(5,2)) # 몫과 나머지를 튜플로 반환

quotient, remainder = divmod(5,2)
print(quotient, remainder)

# 숫자 계산
print(1 - 2)
print(1 + 2)
print(1 * 2)
print(1 / 2)

print(2**3)    # 2^3 = 8


print(5 // 2) # 나머지를 버리고, 몫만 취함
print(5 % 2)  # 몫은 버리고, 나머지만 취함

print(divmod(5,2)) # 몫과 나머지를 튜플로 반환

quotient, remainder = divmod(5,2)
print(quotient, remainder)


print(int(3.3)) # 정수만 취함
print(int(5/2))
print(int('10'))  # '10': 정수로 된 문자열은 가능

# 객체의 자료형
print(type(1))
print(type(1.0))
print(type('1'))

# 2진수, 8진수, 16진수

# 2진수: 숫자 앞에 0b(binary, 2진수)를 붙이고, 숫자는 0 or 1
print(0b110)

# 8진수: 숫자 앞에 0o(octal, 8진수)를 붙이고, 숫자는 0~7까지 사용
print(0o11)

# 16진수: 숫자 앞에 0x(hexadecimal, 16진수)를 붙이고, 숫자는 0~9, A~F(a~f)까지 사용
print(0xB)  # A: 10, B: 11, ... F: 15

'''
아파트에서 소음이 가장 심한 층수를 구하는 계산식은 아래와 같다.

계산식: 소음이 가장 심한 층 = 0.2467 * 도로와의 거리(m) + 4.159

도로와의 거리가 14m인 아파트에서 소음이 가장 심한 층수는?

단, 층수를 출력할 때는 소수점 이하 자리는 버린다. (즉, 정수로 출력).
'''

h = 0.2467 * 14 + 4.159
print(h)
print(int(h))
print(round(h)) # 반올림하는 함수 round()













dist_road = 14
h = 0.2467 * dist_road + 4.159
print(h)
print(int(h))
print(round(h))

# 변수 한번에 입력하기 1

x, y, z = 10, 'hello', 2.6
#x, y, z = (10, 'hello', 2.6)

print(x, type(x))
print('-'*50)
print(y, type(y))
print('-'*50)
print(z, type(z))

# 변수 한번에 입력하기 2

x, y, z = 10   # 에러 발생함

print(x)
print(y)
print(z)

# 변수 한번에 입력하기 3 (위의 방법 대신 이렇게 해야 함)

x = y = z = 10

print(x, y, z)

# 문자열 포매팅

x = y = 10
z = 'cat'

print(x, y, z)

print('x is', x, ', y is', y, ', z is', z)
print('x is {}, y is {}, z is {}'.format(x,y,z))
print(f'x is {x}, y is {y}, z is {z}')
print('x is %d, y is %d, z is %s' %(x,y,z)) # %formatting (old version)

# 변수 swap

x, y = 10, 20
x, y = y, x

print(x, y)

# 파이썬과 같이 swap을 지원하지 않을 경우
# 아래와 같은 방법으로 변수를 swap 함

x, y = 10, 20
tmp = x
x = y
y = tmp

print(x,y)

# 변수 삭제

x = 10
print(f'(before del) x is {x}')

del x

print(f'(after del) x is {x}')  # 여기에서 에러 발생함

# 빈 변수 만들기

x = None
print(x)

# 산술 연산(+,-,*,/, //) 후 할당 연산자(=) 사용

a = 10
a = a + 20

# a += 20  # a = a+20

print(a)

a += 10 # a = a + 10과 같음
print(a)

a -= 10 # a = a - 10과 같음
print(a)

a *= 10 # a = a * 10과 같음
print(a)

a /= 10 # a = a / 10과 같음
print(a)

a //= 10 # a = a // 10과 같음
print(a)

x = input('숫자를 입력하시오:') # hello 입력
print(type(x))
print('-'*20)

x = int(input('숫자를 입력하시오:')) # hello 입력
print(type(x))
print('-'*20)

# input 함수 1

x = input() # hello 입력
print(type(x))
print('-'*20)

x = input('문자열을 입력하세요: ') # hello 입력
print(type(x))
print('-'*20)

x = input('숫자를 입력하세요: ') # 숫자 10 입력
print(type(x))

# input 함수 2

a = input('첫 번째 숫자를 입력하세요: ')
b = input('두 번째 숫자를 입력하세요: ')
c = a + b

print(c) # 여기의 출력은 3이 아니라 '12' 임
print(type(c))

# input 함수 3 (숫자 입력을 input으로 받을 때, int를 사용하면 정수가 출력됨)

a = int(input('첫 번째 숫자를 입력하세요: '))
b = int(input('두 번째 숫자를 입력하세요: '))
c = a + b

print(c)
print(type(c))

### 논리 연산자에서
### 1 -> True (참)
### 0 -> False (거짓)

'''
while True:
    # 무한루프

while 1:
    # 무한루프
'''

# 논리 연산자(and)

print(True and True)
print('-'*10)

print(True and False)
print('-'*10)

print(False and True)
print('-'*10)

print(False and False)
print('-'*10)

print(1 and 1)
print(1 and 0)

# 논리 연산자(or)

print(True or True)
print('-'*10)

print(True or False)
print('-'*10)

print(False or True)
print('-'*10)

print(False or False)

# 논리 연산자(not)

print(not True)
print('-'*10)

print(not False)

print(10 == 10)  # true
print(10 != 5)   # true

# 논리 연산자와 비교 연산자

print(10 == 10 and 10 != 5)
print('-'*10)

print(10 > 5 or 10 < 3)
print('-'*10)

print(not 10 > 5)
print('-'*10)

# boolean : Ture / False

# 정수 0, 실수 0.0, 복소수 0j 이외의 모든 숫자는 true
print(bool(1))
print(bool(0))
print(bool(-1))
print('-'*50)


# 빈 문자열 '', "", None을 제외한 모든 문자열은 true
print(bool(None))
print(bool('st'))
print(bool(''))
print('-'*50)

# 빈 리스트, 빈 튜플, 빈 딕셔너리, 빈 세트(집합)를 제외한 나머지는 true
print(bool([]))
print(bool(()))
print(bool({}))
print(bool(set()))

'''
국어(kor), 영어(eng), 수학(math), 과학(sci) 점수가 있을 때
한 과목이라도 50점 미만이면 불합격이다.
아래 조건에 대해서 합격이면 True, 불합격이면 False가 출력되게 만드시오.
kor = 92
eng = 47
math = 86
sci = 70
'''

kor, eng, math, sci = 92, 47, 86, 70
print(kor >= 50 and eng >= 50 and math >= 50 and sci >= 50)











kor = 92
eng = 47
math = 86
sci = 70

print(kor >= 50 and eng >= 50 and math >= 50 and sci >= 50)

# 리스트 1: []로 데이터를 표현

a = []        # 빈 리스트
b = [1, 2, 3] # 각 값은 콤마로 구분

print(a)
print(type(a))
print('-'*20)

print(b)
print(type(b))
print('-'*20)

'''
# 아래는 에러 발생, 각 값을 콤마로 구분짓지 않아서
c = [1 2 3]
print(c)
print(type(c))
'''



# 리스트 2

person = ['james', 17, 175.3, True] # 다양한 자료형을 저장
print(person)

person[2] = 190   # 값 변경 가능
print(person)

a = [12, [123, 3], (12,2)]
print(a)

# range(start=0, end, increment=1)
# range(end)
a0 = range(5) # iterable 객체
print(a0)
print(f'a0 type is {type(a0)}')
print('-'*30)

a = list(range(5)) # range(5) == range(0, 5, 1)
print(a)
print('-'*30)

b = list(range(1,4))
print(b)
print('-'*30)

# range와 list

print(range(10))
print('-'*30)

print(list(range(10)))
print('-'*30)

print(list(range(5,12)))  # 시작, 끝
print('-'*30)

print(list(range(-4,10,2))) # 시작, 끝, 증가폭
print('-'*30)

print(list(range(10,0,-1)))

# 튜플 tuple 1: () 표현

a = ()        # 빈 리스트

b = (1, 2, 3) # 각 값은 콤마로 구분

c = 1,        # 요소가 하나 들어있는 튜플

d = (2,)      # 요소가 하나 들어있는 튜플

e = 1         # 얘는 정수

print(a)
print(type(a))
print('-'*20)

print(b)
print(type(b))
print('-'*20)

print(c)
print(type(c))
print('-'*20)

print(d)
print(type(d))
print('-'*20)

print(e)
print(type(e))

# 튜플 tuple 2

person = ('james', 17, 175.3, True) # 다양한 자료형을 저장
print(person)
print('-'*20)

print(person[2])

person[2] = 190   # 튜플은 값 변경 불가능 (중요: 리스트와 차이점임 !!!)
print(person)

# 리스트 -> 튜플 -> 리스트 -> 튜플
# 이걸(튜플 -> 리스트 -> 튜플) 이용해서 튜플 값을 변경할 수 있음

a = [1, 2, 3]
b = tuple(a)
c = list(b)
c[1] = 100
d = tuple(c)

print(a)
print(b)
print(c)
print(d)

# 문자열

hello = 'hello'
print(hello[2])

hello[2] = 'm'  # error 발생
print(hello)

# 문자열과 list, tuple

hello = 'hello'

print(list(hello))
print(tuple(hello))

# 문자열과 tuple

hello = 'hello'
hello[2] = 'm'

print(hello)

"""##### 시퀀스 자료형: 리스트, 튜플, range, 문자열(str) -> 값이 연속적으로 이어짐

![011001.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA8AAAALQCAMAAAEfrtkQAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADbUExURf///7e3tyAgIAAAAJ+fnxgYGAgICHJycgsLC+rq6vv7+01NTX9/f97e3hEREff39x4eHjIyMvX19aenp52dnQYGBsnJyeLi4m1tbT8/P9TU1Hl5eV1dXebm5q+vr1BQUExMTHt7e7i4uMPDwy0tLWdnZ3Nzc729vUBAQMHBwaKiovHx8dfX10dHRyUlJSgoKIiIiLKystDQ0N/f35eXl29vbzMzM4eHh2hoaFRUVERERJKSkmJiYtvb22tra4yMjFpaWnZ2dr+/vx0dHTo6OoODg35+fsjIyAAAAAKXJhkAAABJdFJOU////////////////////////////////////////////////////////////////////////////////////////////////wAMCJ9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAuFElEQVR4Xu3dzZKqPBCAYUvWurHKO7BcsJmFNVWy8/5v6nQnHUgCRASV0fM+33cUCJ0fQgAdlQ0AAACAP6aqbMLLZkdUP+5R1727/tgKswquNb/LPkxvNlf36Ke9JiwZyrCRf1rSr5/dXBs3G4WPqxyd0Lmrzz56bMK0f05pogTvbHaz2aYFD8U8jat1J5t9Kr+RZBskRmYtBsBflg3VaSPXjXObnmtWwft2rei47o/47rw1erANq99cSVeb22wO0xuy9Sse3aPncq2Lp5iwuqylJYWzk5hccEtPcUOP92QlPV7wXKsVDGCBcBlnzyaffbknHUAmhkWraUlhVicn5aAvTLZ2iqoOezlj7Db+Bc0d0WE8LskKLp5fWjs5tS0RFyznx2ktfoaspPcVDGCBcBqwZxNm9/7J1n2hWQeQrXus9UnfuXHv33Rv4UyjJYXC5CA9rWDZJFqoW9c97A76OJ0WGpVkBUdLRoQTk55Ojhozrb4d/9qpLUkno9nXyur6aNUf4Xfb1S99AAAAAAAAAOAvK79re+ddVJ+qK939A2hvhUUFK/2L7Hm04It7zD98c5UFcdbbXzcbltgHUosuVSX/36Tgs5vXx300nT62tlawLbZ6tH969h9IvSz8A/GIrE3l2eew9+DNnVkAf1j5iHFn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)
"""

# 시퀀스 자료형 1(특정 값이 있는지 확인)

a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90] # 시퀀스 자료형
print(30 in a)  # in: ~에 들어있는
print(100 in a)
print('-'*10)

print(100 not in a) # not in: ~에 들어있지 않은
print(30 not in a)
print('-'*10)

print(1 in range(10))   # range도 시퀀스 자료형
print(11 in range(10))
print('-'*10)

print('p' in 'python')  # string도 시퀀스 자료형
print('P' in 'python')

# 시퀀스 자료형 2-1 (시퀀스 객체 연결하기)

a = [0, 10, 20, 30]
b = [9, 8, 7, 6]
print(a + b)
print('-'*30)

print('hello' + '' + 'python')
print('hello' + ' ' + 'python')

# 시퀀스 자료형 2-2 (시퀀스 객체 연결하기)

print(range(0, 10) + range(90, 100))

# 시퀀스 자료형 2-3 (시퀀스 객체 연결하기)

# range는 리스트나 튜플로 만들어서 연결
print(list(range(0, 10)) + list(range(90, 100)))

# 시퀀스 자료형 3 (시퀀스 객체 반복하기)

print([1, 2, 3, 4]*3)

print('-'*70)

# 시퀀스 자료형 4 (리스트, 튜플, range의 숫자 생성, 요소 개수 구하기)

a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
print(len(a))

b = (38, 76, 43, 62, 19)
print(len(b))

print('-'*10)

print(len(range(0, 10, 2)))

print(len('hello python'))

# 시퀀스 자료형 5 (인덱싱): 하나의 요소만 access함

a = [38, 21, 53, 62, 19]
print(a[0])
print(a[2])
print(a[4])
print('-'*10)

b = (38, 21, 53, 62, 19)
print(b[0])
print(b[2])
print(b[4])
print('-'*10)

print(range(0, 10, 2)[0])
print(range(0, 10, 2)[2])
print(range(0, 10, 2)[4])
print('-'*10)

print('hello'[0])
print('-'*10)

a = [38, 21, 53, 62, 19]
#    0,   1,  2,  3,  4  (+) 인덱스
#    -5, -4, -3, -2, -1  (-) 인덱스

print(a[len(a)-1])
print(a[-1])
print(a[-3])
print(b[-1])
print('-'*10)

print(range(0, 10, 2)[-1])
print('hello'[-1])

# 시퀀스 자료형 6 (슬라이싱) : 여러 개의 요소를 access함

a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
print(a[0:4])
print('-'*30)

print(a[1:2])
print('-'*30)

print(a[:7])  # 0번째 부터 (7-1)번째 까지
print('-'*30)

print(a[7:])  # 7번째 부터 끝까지 인덱싱
print('-'*30)

print(a[:])   # 모두 (all)
print('-'*30)

print(a[1:1]) # []
print('-'*30)

print(a[2:8:3]) # 이오 요구르트
print('-'*30)

print(a[::-1])  # 역으로 접근 (거꾸로 모두 읽음)

# 딕셔너리 1: {} 로 표현. {키 : 값} :을 기준으로 왼쪽은 키, 오른쪽은 값

x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}

print(x)
print(x.keys())
print(x.values())
print(x['a'])  # 키를 인덱싱하면 value를 알수있다
print(x['c'])
print('-'*30)

y = {4: 'four', 3: 'three', 2: 'two'}
print(y)
print(y.keys())
print(y.values())
print(y[4])
print(y[2])

# 딕셔너리 2-1: 키에는 리스트와 딕셔너리를 사용할 수 없음

#x = {[10, 20]: 100}
x = {{'a': 10}: 100}

# 딕셔너리 2-2: 값에는 리스트와 딕셔너리를 사용할 수 있음

#x = {3: [10, 20]}
x = {1: {2:100}}
print(x[1])
print(x.values())

# 딕셔너리 3
a = {}  # 빈 딕셔너리 : 빈 리스트 [], 빈 튜플 (), 빈 세트 a = set()
print(a, type(a))

# 딕셔너리 만들기1: dict(키1=값1, 키2=값2)
dic = dict(a=10, b=20, c=30)
print(dic)
print('-'*30)

# 딕셔너리 만들기2: dict(zip([키1, 키2], [값1, 값2]))
dic2 = dict(zip(['a', 'b', 'c'], [10, 20, 30]))
print(dic2)
print('-'*30)

# 딕셔너리 만들기3: dict([(키1, 값1), (키2, 값2)])
dic3 = dict([('a', 10), ('b', 20), ('c', 30)])
print(dic3)
print('-'*30)

# 딕셔너리 만들기4: dict({키1: 값1, 키2: 값2})
dic4 = dict({'a': 10, 'b': 20, 'c': 30})
print(dic4)
print('-'*30)

# 딕셔너리 만들기5: {키1: 값1, 키2: 값2}
dic5 = {'a': 10, 'b': 20, 'c': 30}
print(dic5)
print('-'*30)

print('a' in dic4)  # 딕셔너리 키 유무 확인
print('d' in dic4)
print('-'*30)

print(len(dic4))  # 딕셔너리 키 개수

# set 1: set 만들기

a = set() # 빈 세트
print(a, type(a))
print('-'*20)

b = {}
print(b, type(b))
print('-'*20)

# set의 특징1: 중복 허용하지 않음
c = set('apple') # 출력 결과가 a, p, p, l, e 가 아님
print(c)

# set 2: 특징2: 세트의 요소는 순서가 정해져 있지 않음 ==> 그래서 인덱싱을 할 수 없음

fruits = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}
print(fruits)
print('-'*50)

print(fruits[1]) # grape일까?

# set 3: 세트의 특정 요소가 있는지 확인하기

fruits = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}
print('orange' in fruits)
print('-'*10)

print('peach' in fruits)
print('-'*10)

print('peach' not in fruits)
print('-'*10)

print('orange' not in fruits)

# set 4: 세트에 들어가는 요소는 중복되지 않음

fruits = {'strawberry', 'orange', 'orange'}
print(fruits)

# if 문 1

# if 조건문:
#    조건이 true일 때 실행할 코드 (앞 부분은 들여쓰기 되어 있음)

a = 10
if a == 10:
    print('10입니다')

print('aaa')
print('-'*15)

a = 5
if a == 10:
    print('10입니다')

print('aaa')

# 코드 블록:
# - 특정한 동작을 위해서 코드가 모여 있는 상태
# - 파이썬은 들여쓰기를 기준으로 코드 블록을 구성
# - 같은 블록은 들여쓰기 칸 수가 같아야 하고, space와 tab을 섞어 쓰면 안됨

a = 10

if a == 10:
    print('10입니다')
    print('10입니다')
    print('10입니다')
    print('10입니다')
    print('10입니다')

if a != 9:
    print('9가 아닙니다')
      print('')

# if 문 2

x = 5

if x == 10:
    print('x에 들어있는 숫자는')
print('10입니다')

if x == 10:
    print('x에 들어있는 숫자는')
    print('10입니다')

# if-else 구문

x = 10
y = 20

if x == 10 and y == 20:  # x == 10 and y == 20 이 조건문
    print('참')    # 조건문이 참이면 실행
else:
    print('거짓')  # 조건문이 거짓이면 실행

# 중첩 if문과 논리 연산자

x = 10

if x > 0:
    if x < 20:
        print('20보다 작은 양수입니다')

if x > 0 and x < 20:
    print('20보다 작은 양수입니다')

if 0 < x < 20:
    print('20보다 작은 양수입니다')

# if 조건문에서 코드 생략하기

a = 5

if a == 10:
    print('a는 10')
else:
    pass

'''
S기업의 입사시험은 필기시험(written_test) 점수가 80점 이상이면서 코딩시험(coding_test)을
통과해야 합격이라고 한다. 코딩시험 통과 여부는 True, False로 구분한다.
written_test = 85이고, coding_test = True일 때, 'pass', 'fail'을 판정하는 코드를
작성하시오.
'''

written_test = 85
coding_test = True

if (written_test >= 80 and coding_test):
    print('pass')
else:
    print('fail')

